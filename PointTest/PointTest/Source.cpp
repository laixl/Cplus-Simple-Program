#include <iostream>
using namespace std;

int main()
{
	int *p1, *p2;//声明了两个指针变量，即有两个内存地址首字节记为P1、p2，而地址的长度由指针的类型（int\double等）来决定，
				 //但是这两个指针现在没有指向，也就是这两个地址是空的，即两个指针没有初始化
	int v;
	int *p3;

	/*第一个例子*/
	p1 = new int;//创建一个int类型的无标识符变量，并将指针变量p1设置成这个新变量的地址
				 //即让p1指向这个新的无名变量
				 //如果该程序中没有这一行，直接接 *p1 = 42；那么会编译出错，因为指针变量p1是没有指向的，即没有被初始化，
				 //注意：将提领操作符*应用于一个指针变量之前，首先要确定该指针变量是否已经指向一个实际存在的变量
				 //未定义的指针变量称为虚悬指针

	*p1 = 42;//注意此处的星号* ，与指针声明处的星号含义不同，该*称为提领操作符，表示指针变量p1所指向的变量
	p2 = p1;//将指针变量p1的值（即某个地址，但是具体地址的数值我们并不关心）赋给另一个指针变量p2,
			//这会将地址从一个指针变量复制给另一个指针变量，这意味着指针变量p1和p2会有相同的指向
	
	cout << "*p1==" << *p1 << endl;
	cout << "*p2==" << *p2 << endl;
	cout << "p1==" << p1 << endl;
	cout << "p2==" << p2 << endl;

	*p1 = 53;
	//如果这里是*p2 = 53;以下输出结果一样
	//因为p2=p1，所以只要给其中（*p1或*p2）的一个赋值，就会改变*p1和*p2的值
	//这是因为p1和p2都指向了那个无标识符的变量，*p1和*p2都代表了该变量，*p1的值和*p2的值就是该变量的值
	cout << "*p1==" << *p1 << endl;
	cout << "*p2==" << *p2 << endl;
	cout << "p1==" << p1 << endl;
	cout << "p2==" << p2 << endl;

	p1 = new int;
	*p1 = 88;
	cout << "*p1==" << *p1 << endl;
	cout << "*p2==" << *p2 << endl;
	cout << "p1==" << p1 << endl;
	cout << "p2==" << p2 << endl;


	/*第二个例子*/
	//将指针变量p3“指向变量v”，即指针变量p3包含变量v的地址，即指针变量p3是“变量v的指针”
	p3 = &v;//用操作符&获取变量的地址，再将地址赋给指针变量
	v = 7;
	cout << "v==" << v << endl;//这里相等很好理解，看下面
	cout << "*p3==" << *p3 << endl;

	//v的值会改变，因为p3包含指向v的指针，所以v和*p3引用同一个变量
	//即*p3表示的就是指针变量p3所指向的变量，p3=&v代表着指针变量p3指向了变量v，所以改变*p3就相当于改变v
	*p3 = 9;
	cout << "v==" << v << endl;
	cout << "*p3==" << *p3 << endl;

	delete p1;//销毁动态变量
	return 0;
}

